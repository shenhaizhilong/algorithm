package com.hui.algorithm;

import java.util.*;

/**
 * @author: shenhaizhilong
 * @date: 2018/12/3 11:14
 *
 * 928. Minimize Malware Spread II
 * DescriptionHintsSubmissionsDiscussSolution
 * (This problem is the same as Minimize Malware Spread, with the differences bolded.)
 *
 * In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
 *
 * Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.
 *
 * Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.
 *
 * We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
 *
 *
 *
 * Example 1:
 *
 * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * Output: 0
 * Example 2:
 *
 * Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
 * Output: 1
 * Example 3:
 *
 * Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
 * Output: 1
 *
 *
 * Note:
 *
 * 1 < graph.length = graph[0].length <= 300
 * 0 <= graph[i][j] == graph[j][i] <= 1
 * graph[i][i] = 1
 * 1 <= initial.length < graph.length
 * 0 <= initial[i] < graph.length
 *
 *
 */
public class MinimizeMalwareSpreadII {
    public int minMalwareSpread(int[][] graph, int[] initial) {

        int N = graph.length;

      Set<Integer> virus = new HashSet<>();
      for(int v: initial)virus.add(v);

        UnionFindII unionFindII = new UnionFindII(N);


        // up triangle，连接不包涵任何病毒节点的其他节点
        for (int i = 0; i < N; i++) {
            for (int j = i +1; j < N; j++) {
                if(graph[i][j] == 1 && !virus.contains(i) && !virus.contains(j))
                {
                    unionFindII.union(i,j);
                }
            }
        }


        int min = Integer.MAX_VALUE;

        // 计算每个连通分量里面不同病毒的数量
        Map<Integer,List<Integer>> comp_infect = new HashMap<>();
        for(int i: initial)
        {
            for (int j = 0; j < N; j++) {
                if(!virus.contains(j) && graph[i][j] == 1)
                {
                    int parent = unionFindII.find(j);
                    List<Integer> uniqVirusList = comp_infect.get(parent);
                    if(uniqVirusList == null)
                    {
                        uniqVirusList = new ArrayList<>();
                    }
                    uniqVirusList.add(i);
                    comp_infect.put(parent, uniqVirusList);

                }

            }
            min = Math.min(min, i);
        }

        int[] ans = {-1,-1};//  index   and  size

        // 如果这个连通分量里面有多个病毒或者零个病毒，那么忽略；只考虑这个连通分量有一个病毒的情况
        for(int node: comp_infect.keySet())
        {
            if(comp_infect.get(node).size() == 1)  // just only one node in one set
            {
                int size = unionFindII.getSize(node);
                if(ans[1] < size)
                {
                    ans[1] = size;
                    // 得到病毒的索引
                    ans[0] = comp_infect.get(node).get(0);
                }else if(ans[1] == size)
                {
                    ans[0] = Math.min(ans[0], node);
                }
            }
        }
        // if no just only one node in one set, return min(initial)
        return ans[0] == -1? min: ans[0];

    }

    public static void main(String[] args) {
        int[][] graph = {
                {1,1,0},
                {1,1,1},
                {0,1,1}};
        int[] virus = {0,1};
        MinimizeMalwareSpreadII minimizeMalwareSpreadII = new MinimizeMalwareSpreadII();
        System.out.println(minimizeMalwareSpreadII.minMalwareSpread(graph,virus));


        int[][] graph2 = {
                {1,0,0,0,0,0,0,0,0,0},
                {0,1,0,0,0,0,0,0,0,0},
                {0,0,1,0,0,0,0,0,0,0},
                {0,0,0,1,0,0,0,0,0,0},
                {0,0,0,0,1,0,0,0,0,0},
                {0,0,0,0,0,1,0,0,1,0},
                {0,0,0,0,0,0,1,0,0,0},
                {0,0,0,0,0,0,0,1,0,1},
                {0,0,0,0,0,1,0,0,1,0},
                {0,0,0,0,0,0,0,1,0,1}};

       int[] virus2 =  {3,8};


       //System.out.println(minimizeMalwareSpreadII.minMalwareSpread(graph2,virus2));

    }

}
